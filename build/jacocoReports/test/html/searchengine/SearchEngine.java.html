<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="da"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SearchEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">searchengine</a> &gt; <a href="index.source.html" class="el_package">searchengine</a> &gt; <span class="el_source">SearchEngine.java</span></div><h1>SearchEngine.java</h1><pre class="source lang-java linenums">package searchengine;

import java.util.*;
import java.util.stream.Collectors;

/**
 * A searchengine class to handle complex queries and ranks the result in descending order according to their 
 * TF-IDF rank
 * 
 * @author simol, gega, madbe, elsb
 */

public class SearchEngine {

    private List&lt;Page&gt; result;
    private InvertedIndex index;
    private List&lt;HashSet&lt;Page&gt; &gt; setOfPages;
    private RefinedQuery query;
    private TFIDF tfidfscore;
    private TF tfscore;
<span class="fc" id="L21">    private final boolean TrueForTF = false;</span>

<span class="fc" id="L23">    public SearchEngine() {</span>

<span class="fc" id="L25">      tfscore = new TF();</span>
<span class="fc" id="L26">      tfidfscore = new TFIDF();</span>
<span class="fc" id="L27">      query = new RefinedQuery();</span>
<span class="fc" id="L28">      result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L29">      index = new InvertedIndex();</span>
<span class="fc" id="L30">      setOfPages = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L32">    }</span>
    
    /**
     * 
     * @param websites - takes a hashSet of pages as input
     *
     *@Description converts a hashset of pages into a map with the inverted index methods
     * and maps words to a number of webpages
     * 
     */

    public void makeIndex(HashSet&lt;Page&gt; websites){

<span class="fc" id="L45">      index.makeInvertedIndex(websites);</span>

<span class="fc" id="L47">    }</span>

    /**
     * Clarification: 
     * To use either the TF or the TF-IDF ranking, we implemented a final boolean field called TrueForTF
     * which means if its true, it ranks the pages in descending order to the TF-ranking, or the TF-IDF ranking
     * if the TrueForTF field is false
     * 
     * this method returns either a TF or a TF-IDF score depending on wether the TrueForTF field is true or false.
     * we decided to use the TF-IDF score as a final score for the pages to get a more deeper score. 
     * Thats why the TrueForIDF field is false;
     * 
     * 
     * @param trueForTF
     * takes boolean thats either TRUE to get TF-scores or FALSE to get TF-IDFscores
     * @param searchTerm
     * a searchTerm as a string
     * @param page
     * a lookedUp page from the set of pages found by the searchword
     * @param idx
     * the invertedindex object to find the set of pages found by a specific searchword
     * @return
     * returns a double
     */

     public double getTForTFIDF(boolean trueForTF, String searchTerm, Page page, InvertedIndex idx) {
  
<span class="fc bfc" id="L74" title="All 2 branches covered.">       if(trueForTF == true){</span>
<span class="fc" id="L75">          return tfscore.TFScore(searchTerm, page);</span>
        } else {
<span class="fc" id="L77">          return tfidfscore.TFIDFscore(searchTerm, page, idx);</span>
        }
    }

    /**
     * First we put every entries from a map into an list. After that we sort each entry in the map / list by
     * comparing the entries value (TF/TF-IDF score) to sort them in descending order.
     * 
     * We then convert the list into a simple arraylist consisting of pages instead of map entries. We use the stream method
     * to get all the keys from the other list and keep the order of the TF/TF-IDF ranking in descending matter.
     * 
     * @param map 
     * takes a map and list as a parameter
     */

    public List&lt;Page&gt; getDescendingListFromMap(Map&lt;Page , Double&gt; map, List&lt;Page&gt; list){
      
<span class="fc" id="L94">      List&lt;Map.Entry&lt;Page, Double&gt;&gt; pagescores = new ArrayList&lt;&gt;(map.entrySet());</span>
<span class="fc" id="L95">      Collections.sort(pagescores, (page1, page2) -&gt; page2.getValue().compareTo(page1.getValue()));</span>

<span class="fc" id="L97">      list = pagescores.stream().map(Map.Entry::getKey).collect(Collectors.toList());</span>
      
<span class="fc" id="L99">      return list;</span>
      
    }

    /**
     * This method calculates the TF/TF-IDF for every page belonging to the HashSet of Pages
     * thats found by the searchword!
     * If a searchword is split by &quot;OR&quot; and it has multiple words on each side,
     * then it loops through all the multiple words on every side split by &quot;OR&quot;,
     * and computes the sum!
     * 
     * if searchweard is e.g &quot;java asia OR borneo indonesia&quot;, then it finds the score of
     * &quot;java&quot; and adds its to &quot;asia&quot; on the left side of &quot;OR&quot;!
     * 
     * IF and only if, a page contains all the words, java, asia, borneo and indonesia
     * then it takes the maximum value of the two sums, which will be the final TF/TF-IDF score
     * of the page! 
     * 
     * @param map
     * @param searchWords
     * @param list
     * @param idx
     * 
     */

    public void computeTForTFIDF(boolean tfOrTfidf, Map&lt;Page, Double&gt; map, String [] searchWords, List&lt;HashSet&lt;Page&gt;&gt; list, InvertedIndex idx, RefinedQuery q){
      
<span class="fc" id="L126">      double initialscore = 0.0;</span>
<span class="fc" id="L127">      double score = 0.0;</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">        for (Page page : q.getUniqueList(list)) {</span>

<span class="fc bfc" id="L131" title="All 2 branches covered.">          if(!map.containsKey(page)){</span>

<span class="fc bfc" id="L133" title="All 2 branches covered.">            for (String w : searchWords) {</span>

<span class="fc" id="L135">              initialscore = getTForTFIDF(tfOrTfidf, w, page, idx);</span>
              
<span class="fc" id="L137">              page.addFirstScore(initialscore);</span>
              
            }

<span class="fc" id="L141">              map.put(page, page.getFirstScore());</span>

<span class="fc" id="L143">              page.currentscore(page.getFirstScore());</span>

<span class="fc" id="L145">              page.resetFirstScore();</span>

          } else {

<span class="fc bfc" id="L149" title="All 2 branches covered.">            for (String w : searchWords) {</span>
              
<span class="fc" id="L151">              score = getTForTFIDF(tfOrTfidf, w, page, idx);</span>
              
<span class="fc" id="L153">              page.addSecondScore(score);</span>
              
            }

<span class="fc bfc" id="L157" title="All 2 branches covered.">            if(page.getSecondScore() &gt; page.getCurrentScore()) {</span>

<span class="fc" id="L159">              map.replace(page, page.getFirstScore(), page.getSecondScore());</span>
              
<span class="fc" id="L161">              page.currentscore(page.getSecondScore());</span>

<span class="fc" id="L163">              page.resetSecondScore();</span>
             
            } 
          
        } 
<span class="fc" id="L168">      }</span>

<span class="fc" id="L170">    }</span>

    /**
     * 
     * This is the main method of this class
     * 
     * This methods takes a searchterm and can handle the different queries in specific manners:
     * 
     * If the searchterm consist of a single word, 
     * then it only finds the pages related to that word and assigns a TF/TF-IDF score to each page.
     * 
     * If the searchterm consist of a two words split by whitespace, then it only finds pages containing both words, and
     * each page will be assigned a TF/TF-IDF that will be accumulated as a sum of boths word's TF/TF-IDF score on the page. 
     * in other words, if the search word are &quot;asia java&quot;, then the page will be assigned a sum of &quot;asia&quot; and &quot;java&quot;s TF/TF-IDF score 
     * 
     * If the searchterm consist of two words split by &quot;OR&quot; for example:
     * &quot;asia OR java&quot;
     * then a page's TF/TF-IDF score will be the maximum score of those two.
     * 
     * If the searchterm consist of multiple words split by &quot;OR&quot; for example:
     * &quot;asia java OR borneo indonesia&quot;
     * then if a page has all the words (asia, java, borneo, indonesia), the TF/TF-IDF score of a page
     * will be the maximum sum of either &quot;java asia&quot; or &quot;borneo indonesia&quot;. 
     * 
     * every searchterm will be mapped in a hashmap with pages and their respective accumulated TF-iDF
     * that map will then be converted to a list of pages, where order is sorted by their TF/TF-IDF score in descending order. 
     * 
     * @param searchTerm
     * Takes a searchterm as a string
     * @return
     * A list of pages containing the searchword and each page is 
     * assigned a TF-IDF score accumulated with the searchword / searchwords.
     * The list is ordered by the TF-IDF score of the page in descending order.
     */
    
    public List&lt;Page&gt; getSearchResults(String searchTerm) { 
      
<span class="fc" id="L207">      Map&lt;Page, Double&gt; siteRank = new HashMap&lt;&gt;();</span>
      
<span class="fc" id="L209">      String[] subSearches = searchTerm.toLowerCase().split(&quot;%20or%20&quot;);</span>
      
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (String subsearch : subSearches) {</span>
  
<span class="fc" id="L213">            String[] searchWords = subsearch.split(&quot;%20&quot;); </span>
    
<span class="fc" id="L215">            setOfPages = query.buildPages(index, searchWords);</span>
            
<span class="fc" id="L217">            computeTForTFIDF(TrueForTF, siteRank, searchWords,setOfPages, index, query);</span>

        }
      
<span class="fc" id="L221">      result = getDescendingListFromMap(siteRank,result);</span>

<span class="fc" id="L223">      return result;</span>
          

    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>